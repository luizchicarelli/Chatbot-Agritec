# -*- coding: utf-8 -*-
"""AgroAssist

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14J76fswkCY6-OoTq1UZ-UeY4HuPOxZez

# Carregamento de bibliotecas e valida√ß√£o do token de acesso
"""

# -----------------------------------------------------------------------------
# CHATBOT AGRITEC - VERS√ÉO 4.0 (EST√ÅVEL E REVISADA)
#
# Principais Corre√ß√µes nesta vers√£o:
# - A fun√ß√£o de Aduba√ß√£o foi totalmente refeita para usar o endpoint correto
#   `/adubacao-correcao` com todos os par√¢metros obrigat√≥rios.
# - A mensagem de erro da fun√ß√£o Produtividade foi aprimorada.
# - Estabilidade geral e consist√™ncia com a documenta√ß√£o da API v2.
# -----------------------------------------------------------------------------

# ‚¨áÔ∏è Instalar depend√™ncias
!pip install -q requests spacy tabulate
!python -m spacy download pt_core_news_sm

# üì¶ Importar bibliotecas
import base64
import requests
import spacy
from tabulate import tabulate
from datetime import date, datetime
import re
import locale

try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
except locale.Error:
    print("Aviso: Locale 'pt_BR.UTF-8' n√£o encontrado.")

print("Carregando modelo de linguagem...")
nlp = spacy.load("pt_core_news_sm")

# --- CONFIGURA√á√ÉO E AUTENTICA√á√ÉO ---

def get_access_token(consumer_key, consumer_secret):
    """Gera o token de acesso para autentica√ß√£o na API."""
    credentials = f"{consumer_key}:{consumer_secret}"
    auth_header = base64.b64encode(credentials.encode()).decode()
    token_url = "https://api.cnptia.embrapa.br/token"
    try:
        response = requests.post(token_url, headers={"Authorization": f"Basic {auth_header}"}, data={"grant_type": "client_credentials"}, verify=True)
        response.raise_for_status()
        token_data = response.json()
        print("‚úÖ Token de acesso gerado com sucesso!")
        return token_data.get("access_token")
    except Exception as e:
        print(f"‚ùå Erro Cr√≠tico ao gerar token: {e}")
        return None

CONSUMER_KEY = "btKQxdfdvGPPTirf2XbSQcDR_DUa" #
CONSUMER_SECRET = "KadUT3SvDFazTsxsyCMAxJkzsDca" #
ACCESS_TOKEN = get_access_token(CONSUMER_KEY, CONSUMER_SECRET)

HEADERS = {"Authorization": f"Bearer {ACCESS_TOKEN}", "Accept": "application/json"} if ACCESS_TOKEN else {}

# --- BANCO DE DADOS EM MEM√ìRIA ---
CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS = {}, {}, {}, []
UFS_BRASIL = ['AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN', 'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO']

def carregar_dados_da_api():
    """Carrega todos os dados iniciais da API."""
    global CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS
    try:
        r_cult = requests.get("https://api.cnptia.embrapa.br/agritec/v2/culturas", headers=HEADERS)
        r_cult.raise_for_status()
        for item in r_cult.json().get("data", []):
            CULTURAS[item['nome'].lower().replace('√£', 'a').replace('√ß', 'c')] = item['id']
        print("‚úÖ Dados de Culturas carregados.")

        print("‚è≥ Carregando UFs e Munic√≠pios...")
        for uf in UFS_BRASIL:
            ESTADOS[uf.lower()] = uf
            r_mun = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/municipios?uf={uf}", headers=HEADERS)
            if r_mun.ok:
                for mun in r_mun.json().get("data", []):
                    CIDADES_COM_DADOS[mun['nome'].lower()] = str(mun['codigoIBGE'])
        CIDADES_ORDENADAS = sorted(CIDADES_COM_DADOS.keys(), key=len, reverse=True)
        print("‚úÖ Dados de Estados e Cidades carregados.")
        return True
    except Exception as e:
        print(f"‚ùå Falha cr√≠tica ao carregar dados: {e}")
        return False

"""# Execu√ß√£o do chatbot"""

# --- PROCESSAMENTO DE LINGUAGEM NATURAL (NPL) ---
def extrair_entidades(texto):
    texto_norm = texto.lower().replace("√©", "e").replace("√£", "a").replace("√≠", "i").replace("√ß", "c").replace("√¥", "o")
    cultura = next((c for c in CULTURAS if c in texto_norm), None)
    uf = next((val for key, val in ESTADOS.items() if re.search(r'\b' + key + r'\b', texto_norm)), None)
    data_plantio = re.search(r'(\d{1,2}/\d{1,2}/\d{2,4})', texto)
    cidade = None
    for ent in nlp(texto.lower()).ents:
        if ent.label == "LOC" and ent.text.lower() in CIDADES_COM_DADOS:
            cidade = ent.text.lower()
            break
    if not cidade:
        for nome_cidade in CIDADES_ORDENADAS:
            if re.search(r'\b' + re.escape(nome_cidade) + r'\b', texto_norm):
                cidade = nome_cidade
                break
    return cultura, uf, cidade, data_plantio.group(1) if data_plantio else None

def classificar_intencao(texto):
    texto = texto.lower()
    if any(p in texto for p in ["plantar", "plantio", "√©poca", "quando semear", "melhor epoca", "zoneamento"]): return "zoneamento"
    if any(p in texto for p in ["cultivar", "variedade", "semente"]): return "cultivares"
    if any(p in texto for p in ["adubacao", "adubar", "fertilizante", "nutrientes", "solo"]): return "adubacao"
    if any(p in texto for p in ["produtividade", "produ√ß√£o", "rendimento", "quanto produz"]): return "produtividade"
    return "desconhecido"

# --- FUN√á√ïES DE CONSULTA √Ä API (VERS√ÉO 4.0) ---

def consultar_zoneamento(id_cultura, codigo_ibge, cidade_nome):
    """Endpoint: /agritec/v2/zoneamento (com remo√ß√£o de duplicados)"""
    print(f"\nüîé Consultando Zoneamento para {cidade_nome.title()}...")

    tipos_solo = {
        1: "Arenoso",
        2: "M√©dia Textura",
        3: "Argiloso"
    }

    conversao_solo = {
        "AD1": "Arenoso",
        "AD2": "Arenoso",
        "AD3": "media textura",
        "AD4": "media textura",
        "AD5": "argiloso",
        "AD6": "argiloso"
    }

    for risco in [20, 30, 40]:
        encontrou_dados = False
        print(f"\nüìä Resultados para {risco}% de risco:")

        params = {'idCultura': id_cultura, 'codigoIBGE': codigo_ibge, 'risco': risco}
        try:
            r = requests.get("https://api.cnptia.embrapa.br/agritec/v2/zoneamento", headers=HEADERS, params=params)
            if r.status_code == 404:
                continue
            r.raise_for_status()
            dados = r.json().get("data", [])

            if dados:
                encontrou_dados = True
                # remover duplicados pelo par (solo, per√≠odo)
                vistos = set()
                tabela_filtrada = []
                for d in dados:
                    periodo = f"De {d.get('diaIni')}/{d.get('mesIni')} a {d.get('diaFim')}/{d.get('mesFim')}"
                    chave = (d.get('solo'), periodo)
                    if chave not in vistos:
                        vistos.add(chave)
                        nome_solo = conversao_solo.get(d.get('solo'), d.get('solo'))
                        tabela_filtrada.append([nome_solo, periodo])

                # if tabela_filtrada:
                #     print(f"\n‚úÖ Solo: {nome_solo}")
                #     print(tabulate(tabela_filtrada, headers=["Tipo de Solo", "Per√≠odo Recomendado"]))

        except requests.exceptions.HTTPError as err:
            print(f"  - Erro na API para risco {risco}%, solo {nome_solo}: {err.response.status_code}")

        for tipo_solo in tipos_solo.values():
            tabela_solo = [row for row in tabela_filtrada if row[0].lower() == tipo_solo.lower()]
            if tabela_solo:
                print(f"\n‚úÖ Solo: {tipo_solo}")
                print(tabulate(tabela_solo, headers=["Tipo de Solo", "Per√≠odo Recomendado"], tablefmt="pretty"))

        if not encontrou_dados:
            print("‚ùå Nenhuma recomenda√ß√£o encontrada para este risco.")

#WORK IN PROGRESS
def consultar_cultivares(id_cultura, uf):
    """Endpoint: /agritec/v2/cultivares"""
    print(f"\nüîé Consultando Cultivares para a UF {uf}...")
    try:
        r = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])
        if not dados:
            print("‚ùå Nenhuma cultivar encontrada.")
            return
        print("\n‚úÖ Cultivares recomendadas:")
        dados.sort(key=lambda x: x.get('cultivar', ''))
        print(tabulate([[d.get('cultivar'), d.get('potencialProdutivo'), d.get('obtentorMantenedor'), d.get('grupo'), d.get('duracaoCiclo'), d.get('grupoBioClimatico')] for d in dados], headers=["Cultivar", "Potencial Produtivo", "Obtentor", "Ciclo de Desenvolvimento", "Dura√ß√£o do Ciclo", "Grupo Bioclim√°tico"], tablefmt="pretty"))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta: {err.response.text}")

def consultar_adubacao(id_cultura, uf): #precisa de autori
    #Endpoint: /adubacao-correcao - CORRIGIDO
    print(f"\nüîé Consultando Aduba√ß√£o e Corre√ß√£o de Solo para a UF {uf}...")
    params = {
        'idCultura': id_cultura, 'uf': uf, 'texturaSolo': 1, 'produtividadeEstimada': 3000,
        'sistemaPlantio': 1, 'fosforo': 5.0, 'potassio': 0.2, 'aluminio': 0.1,
        'calcio': 2.0, 'magnesio': 0.8, 'vAtual': 40, 'vDesejado': 60
    }
    url = "https://api.cnptia.embrapa.br/agritec/v1/adubacao/recomendacao"
    try:
        r = requests.get(url, headers=HEADERS, params=params)
        r.raise_for_status()
        dados = r.json().get("data", {})
        if not dados:
            print("‚ùå Nenhuma recomenda√ß√£o de aduba√ß√£o encontrada.")
            return
        print("\n‚úÖ Recomenda√ß√µes (baseado em an√°lise de solo gen√©rica):")
        if dados.get('calagem'): print("\n--- Calagem ---"); print(tabulate(dados['calagem'], headers="keys", tablefmt="pretty"))
        if dados.get('gessagem'): print("\n--- Gessagem ---"); print(tabulate(dados['gessagem'], headers="keys", tablefmt="pretty"))
        if dados.get('adubacaoNPK'): print("\n--- Aduba√ß√£o NPK ---"); print(tabulate(dados['adubacaoNPK'], headers="keys", tablefmt="pretty"))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta de aduba√ß√£o: {err.response.text}")

def get_uf_from_ibge(codigo_ibge):
    uf_code = str(codigo_ibge)[:2]
    uf_map = {'11': 'RO', '12': 'AC', '13': 'AM', '14': 'RR', '15': 'PA', '16': 'AP', '17': 'TO', '21': 'MA', '22': 'PI', '23': 'CE', '24': 'RN', '25': 'PB', '26': 'PE', '27': 'AL', '28': 'SE', '29': 'BA', '31': 'MG', '32': 'ES', '33': 'RJ', '35': 'SP', '41': 'PR', '42': 'SC', '43': 'RS', '50': 'MS', '51': 'MT', '52': 'GO', '53': 'DF'}
    return uf_map.get(uf_code)

def obter_primeiro_id_cultivar(id_cultura, codigo_ibge):
    uf = get_uf_from_ibge(codigo_ibge)
    if not uf: return None
    try:
        r = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])
        return dados[0]['idCultivar'] if dados else None
    except:
        return None

#WORK IN PROGRESS
def consultar_produtividade(id_cultura, codigo_ibge, cidade_nome, data_plantio):
    #Endpoint: /agritec/v2/produtividade
    print(f"\nüîé Consultando Produtividade para {cidade_nome.title()}...")
    id_cultivar = obter_primeiro_id_cultivar(id_cultura, codigo_ibge)
    if not id_cultivar:
        # Mensagem de erro aprimorada
        uf = get_uf_from_ibge(codigo_ibge)
        print(f"‚ùå N√£o foi poss√≠vel estimar a produtividade. Motivo: a API n√£o retornou uma 'cultivar' de refer√™ncia para esta cultura na regi√£o de {uf}.")
        print(f"   Tente primeiro a consulta 'cultivares de {CULTURAS.get(id_cultura, 'cultura')} em {uf}' para verificar a disponibilidade de dados.")
        return
    params = {
        'idCultura': id_cultura, 'idCultivar': id_cultivar, 'codigoIBGE': codigo_ibge,
        'dataPlantio': data_plantio.strftime('%Y-%m-%d'),
        'cad': 100, 'expectativaProdutividade': 3000
    }
    try:
        r = requests.get("https://api.cnptia.embrapa.br/agritec/v2/produtividade", headers=HEADERS, params=params)
        r.raise_for_status()
        dados = r.json().get("data", [])
        if not dados:
            print("‚ùå Nenhum dado de produtividade encontrado.")
            return
        print("\n‚úÖ Produtividade esperada:")
        print(tabulate(dados, headers="keys", tablefmt="pretty"))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta de produtividade: {err.response.text}")

# --- L√ìGICA PRINCIPAL DO CHATBOT ---
def chatbot():
    print("üåæ Bem-vindo ao Chatbot Agritec (v4.0 - Est√°vel)!")
    print("\nüìå Exemplos de perguntas:")
    print("   - Quando plantar milho em Piracicaba?")
    print("   - Cultivares de soja para o RS")

    if not ACCESS_TOKEN:
        print("\nüõë Falha na autentica√ß√£o."); return
    if not carregar_dados_da_api():
        print("\nüõë Falha ao carregar dados iniciais."); return

    while True:
        pergunta = input("\n> Digite sua pergunta (ou 'sair'): ")
        if pergunta.lower() == "sair":
            print("üëã At√© logo!"); break

        intencao = classificar_intencao(pergunta)
        cultura, uf, cidade, data_plantio = extrair_entidades(pergunta)
        if data_plantio:
            try:
                data_plantio = datetime.strptime(data_plantio, '%d/%m/%Y').date()
                if data_plantio > date.today():
                    print("‚ùì A data de plantio n√£o pode ser no futuro."); continue
            except ValueError:
                print("‚ùì Formato de data inv√°lido. Use DD/MM/AAAA."); continue

        if not cultura:
            print("‚ùì N√£o identifiquei a cultura (ex: soja, milho)."); continue
        id_cultura_encontrada = next((cid for c, cid in CULTURAS.items() if c == cultura), None)

        if intencao in ["zoneamento", "produtividade"]:
            if not cidade:
                print(f"‚ùì Para '{intencao}', preciso da cidade."); continue
            codigo_ibge = CIDADES_COM_DADOS.get(cidade)
            if intencao == "zoneamento":
                consultar_zoneamento(id_cultura_encontrada, codigo_ibge, cidade)
            else:
                consultar_produtividade(id_cultura_encontrada, codigo_ibge, cidade, data_plantio or date.today())
        elif intencao in ["cultivares", "adubacao"]:
            if not uf:
                print(f"‚ùì Para '{intencao}', preciso do estado (UF)."); continue
            if intencao == "cultivares":
                consultar_cultivares(id_cultura_encontrada, uf)
            else:
                consultar_adubacao(id_cultura_encontrada, uf)
        else:
            print("‚ùì Desculpe, n√£o entendi o que voc√™ precisa. Tente uma pergunta como nos exemplos."); continue

if __name__ == '__main__':
    chatbot()

"""verificar o que tem produtividade"""

import requests

# Configura√ß√µes de autentica√ß√£o
ACCESS_TOKEN = "a6079b00-6084-39f8-af5e-9d297c951a90"  # gere antes com sua fun√ß√£o de autentica√ß√£o
HEADERS = {"Authorization": f"Bearer {ACCESS_TOKEN}", "Accept": "application/json"}

# 1. Pegar todas as culturas
url_culturas = "https://api.cnptia.embrapa.br/agritec/v2/culturas"
resp = requests.get(url_culturas, headers=HEADERS)

if resp.ok:
    culturas = resp.json().get("data", [])
    print(f"üå± {len(culturas)} culturas encontradas.")

    # 2. Testar cada cultura no endpoint de produtividade
    for c in culturas:
        id_cultura = c["id"]
        nome_cultura = c["nome"]

        # exemplo: usando IBGE de Goi√¢nia (GO) = 5208707 (ajuste conforme necess√°rio)
        params = {
            "idCultura": id_cultura,
            "idCultivar": 1,  # placeholder, vamos ver se retorna erro
            "codigoIBGE": 5208707,
            "dataPlantio": "2025-09-01",
            "cad": 100,
            "expectativaProdutividade": 3000
        }

        url_prod = "https://api.cnptia.embrapa.br/agritec/v2/produtividade"
        r_prod = requests.get(url_prod, headers=HEADERS, params=params)

        if r_prod.status_code == 200:
            print(f"‚úÖ Cultura com produtividade dispon√≠vel: {nome_cultura} (ID {id_cultura})")
        else:
            print(f"‚ùå {nome_cultura} sem produtividade ({r_prod.status_code})")
else:
    print("Erro ao consultar culturas:", resp.text)