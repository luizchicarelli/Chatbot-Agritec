# -*- coding: utf-8 -*-
"""AgroAssist v5.1 (Definitivo se Deus quiser)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y6sJx2sp1O8vwBdvdrwv15utYyC3ZW9P

# Carregamento de bibliotecas e valida√ß√£o do token de acesso
"""

# -*- coding: utf-8 -*-
"""AgroAssist - Integrado com ClimAPI, AgroResponde e GEMINI (v5.2 - Final)"""

# -----------------------------------------------------------------------------
# CHATBOT AGRITEC - VERS√ÉO 5.2 (INTEGRA√á√ÉO COMPLETA + GEMINI)
#
# Objetivo: Garantir que o Gemini resuma, traduza termos t√©cnicos e suprima
# a repeti√ß√£o das tabelas brutas da API na resposta final.
# -----------------------------------------------------------------------------

# ‚¨áÔ∏è Instalar depend√™ncias
!pip install -q requests spacy tabulate google-genai
!python -m spacy download pt_core_news_sm

# üì¶ Importar bibliotecas
import base64
import requests
import spacy
import google.generativeai as genai
from tabulate import tabulate
from datetime import date, datetime
import re
import locale
import time

# --- CONFIGURA√á√ÉO DO GEMINI ---
try:
    genai.configure(api_key="AIzaSyAQgeFBFeKwmr3aNZYqIgGZR2XInTy1-Z0") # üëà Coloque sua chave v√°lida
    GEMINI_MODEL = genai.GenerativeModel("models/gemini-2.5-flash")
    print("‚úÖ Gemini configurado.")
except Exception as e:
    print(f"‚ùå Erro ao configurar o Gemini: {e}")
    GEMINI_MODEL = None


# --- CONFIGURA√á√ÉO DE LOCALE E SPACY ---
try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
except locale.Error:
    print("Aviso: Locale 'pt_BR.UTF-8' n√£o encontrado.")

print("Carregando modelo de linguagem...")
nlp = spacy.load("pt_core_news_sm")


# --- CONFIGURA√á√ÉO E AUTENTICA√á√ÉO EMBRAPA ---

CONSUMER_KEY = "D37_xvfvQFC5VDY70pPbh_LcqBIa"
CONSUMER_SECRET = "_GWdEk39t0eqTiWsNvRfGDmUbQoa"
BEARER_TOKEN_EXTRA = "0c74ce67-1971-3cee-a25a-5cd1e657dbee"

def get_access_token(consumer_key, consumer_secret):
    """Gera o token de acesso para autentica√ß√£o na API Agritec."""
    credentials = f"{consumer_key}:{consumer_secret}"
    auth_header = base64.b64encode(credentials.encode()).decode()
    token_url = "https://api.cnptia.embrapa.br/token"
    try:
        response = requests.post(token_url, headers={"Authorization": f"Basic {auth_header}"}, data={"grant_type": "client_credentials"}, verify=True)
        response.raise_for_status()
        token_data = response.json()
        print("‚úÖ Token de acesso Agritec gerado com sucesso!")
        return token_data.get("access_token")
    except Exception as e:
        print(f"‚ùå Erro Cr√≠tico ao gerar token Agritec (Usando Bearer Extra): {e}")
        return BEARER_TOKEN_EXTRA if BEARER_TOKEN_EXTRA != "SEU_BEARER_TOKEN_AQUI" else None

ACCESS_TOKEN = get_access_token(CONSUMER_KEY, CONSUMER_SECRET)

HEADERS = {"Authorization": f"Bearer {ACCESS_TOKEN}", "Accept": "application/json"} if ACCESS_TOKEN else {}

# --- BASES DE URLS ---
BASE_AGRITEC_V2 = "https://api.cnptia.embrapa.br/agritec/v2"
BASE_AGRITEC_V1 = "https://api.cnptia.embrapa.br/agritec/v1"
BASE_CLIM = "https://api.cnptia.embrapa.br/climapi/v1"
BASE_RESPONDE_AGRO = "https://api.cnptia.embrapa.br/respondeagro/v1"
BASE_SMARTSOLOS = "https://api.cnptia.embrapa.br/smartsolos-expert/v1"
BASE_AGROFIT = "https://api.cnptia.embrapa.br/agrofit/v1"
GEOCODE_URL = "https://nominatim.openstreetmap.org/search"

# --- BANCO DE DADOS EM MEM√ìRIA ---
CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS = {}, {}, {}, []
UFS_BRASIL = ['AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN', 'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO']

def carregar_dados_da_api():
    """Carrega todos os dados iniciais da API."""
    global CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS
    try:
        r_cult = requests.get(f"{BASE_AGRITEC_V2}/culturas", headers=HEADERS)
        r_cult.raise_for_status()
        for item in r_cult.json().get("data", []):
            CULTURAS[item['nome'].lower().replace('√£', 'a').replace('√ß', 'c')] = item['id']
        print("‚úÖ Dados de Culturas carregados.")

        print("‚è≥ Carregando UFs e Munic√≠pios...")
        for uf in UFS_BRASIL:
            ESTADOS[uf.lower()] = uf
            r_mun = requests.get(f"{BASE_AGRITEC_V2}/municipios?uf={uf}", headers=HEADERS)
            if r_mun.ok:
                for mun in r_mun.json().get("data", []):
                    CIDADES_COM_DADOS[mun['nome'].lower()] = str(mun['codigoIBGE'])
        CIDADES_ORDENADAS = sorted(CIDADES_COM_DADOS.keys(), key=len, reverse=True)
        print("‚úÖ Dados de Estados e Cidades carregados.")
        return True
    except Exception as e:
        print(f"‚ùå Falha cr√≠tica ao carregar dados: {e}")
        return False

"""# API AGRITEC"""

# --- FUN√á√ïES DE CONSULTA √Ä API (VERS√ÉO 4.0) ---
def consultar_zoneamento(id_cultura, codigo_ibge, cidade_nome):
    """Consulta zoneamento. Retorna string formatada para o Gemini."""
    saida = f"\n[DADOS DE API - ZONEAMENTO AGR√çCOLA PARA: {cidade_nome.title()}]"

    tipos_solo_conv = {
        "AD1": "Arenoso", "AD2": "Arenoso",
        "AD3": "M√©dia Textura", "AD4": "M√©dia Textura",
        "AD5": "Argiloso", "AD6": "Argiloso"
    }

    dados_agregados = {}

    for risco in [20, 30, 40]:
        tabela_risco = []
        params = {'idCultura': id_cultura, 'codigoIBGE': codigo_ibge, 'risco': risco}

        try:
            r = requests.get(f"{BASE_AGRITEC_V2}/zoneamento", headers=HEADERS, params=params)
            if r.status_code == 404:
                saida += f"\n- Risco {risco}%: N√£o h√° dados."
                continue
            r.raise_for_status()
            dados = r.json().get("data", [])

            if dados:
                vistos = set()
                tabela_filtrada = []
                for d in dados:
                    periodo = f"{d.get('diaIni')}/{d.get('mesIni')} - {d.get('diaFim')}/{d.get('mesFim')}"
                    nome_solo = tipos_solo_conv.get(d.get('solo'), d.get('solo'))
                    chave = (nome_solo, periodo)
                    if chave not in vistos:
                        vistos.add(chave)
                        tabela_filtrada.append([nome_solo, periodo])

                if tabela_filtrada:
                    dados_agregados[risco] = {}
                    for row in tabela_filtrada:
                        solo, periodo = row
                        dados_agregados[risco].setdefault(solo, []).append(periodo)

                    header = [f"Risco {risco}%", "Per√≠odos (M√™s/Dia)"]
                    tabela_simples = []
                    for solo, periodos in dados_agregados[risco].items():
                        tabela_simples.append([solo, "; ".join(periodos)])

                    saida += f"\n\n{tabulate(tabela_simples, headers=header, tablefmt='github')}"

        except requests.exceptions.HTTPError as err:
            saida += f"\n- Erro na API para risco {risco}%: Status {err.response.status_code}"

    if not dados_agregados:
        return f"[AUTONOMIA_GEMINI] N√£o foi poss√≠vel encontrar dados de zoneamento para a cultura e cidade solicitadas."

    return saida


def consultar_cultivares(id_cultura, uf):
    """Consulta cultivares. Retorna string formatada para o Gemini."""
    try:
        r = requests.get(f"{BASE_AGRITEC_V2}/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])

        if not dados:
            return f"[AUTONOMIA_GEMINI] Nenhuma cultivar encontrada na base de dados para a cultura e UF ({uf}) solicitadas."

        # Limita a 5 resultados para concis√£o
        dados_limitados = sorted(dados, key=lambda x: x.get('cultivar', ''))[:5]

        tabela = []
        for d in dados_limitados:
            tabela.append([
                d.get('cultivar', 'N/A'),
                d.get('potencialProdutivo', 'N/A'),
                d.get('grupo', 'N/A'),
                d.get('duracaoCiclo', 'N/A')
            ])

        header = ["Cultivar", "Potencial Prod.", "Ciclo de Desenv.", "Dura√ß√£o Ciclo"]
        tabela_str = tabulate(tabela, headers=header, tablefmt="github")

        return f"[DADOS DE API - CULTIVARES PARA UF {uf}]\n{tabela_str}"

    except requests.exceptions.HTTPError as err:
        return f"‚ùå Erro na consulta de cultivares (Status {err.response.status_code})."
    except Exception as e:
        return f"‚ùå Erro inesperado ao consultar cultivares: {e}"

def get_uf_from_ibge(codigo_ibge):
    uf_code = str(codigo_ibge)[:2]
    uf_map = {'11': 'RO', '12': 'AC', '13': 'AM', '14': 'RR', '15': 'PA', '16': 'AP', '17': 'TO', '21': 'MA', '22': 'PI', '23': 'CE', '24': 'RN', '25': 'PB', '26': 'PE', '27': 'AL', '28': 'SE', '29': 'BA', '31': 'MG', '32': 'ES', '33': 'RJ', '35': 'SP', '41': 'PR', '42': 'SC', '43': 'RS', '50': 'MS', '51': 'MT', '52': 'GO', '53': 'DF'}
    return uf_map.get(uf_code)

def obter_primeiro_id_cultivar(id_cultura, codigo_ibge):
    uf = get_uf_from_ibge(codigo_ibge)
    if not uf: return None
    try:
        r = requests.get(f"{BASE_AGRITEC_V2}/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])
        return dados[0]['idCultivar'] if dados else None
    except:
        return None

def consultar_produtividade(id_cultura, codigo_ibge, cidade_nome, data_plantio):
    """Consulta produtividade. Retorna string formatada para o Gemini."""
    id_cultivar = obter_primeiro_id_cultivar(id_cultura, codigo_ibge)
    if not id_cultivar:
        uf = get_uf_from_ibge(codigo_ibge)
        return f"[AUTONOMIA_GEMINI] N√£o foi poss√≠vel estimar a produtividade. Motivo: a API n√£o retornou uma 'cultivar' de refer√™ncia para esta cultura na regi√£o de {uf}."

    params = {
        'idCultura': id_cultura, 'idCultivar': id_cultivar, 'codigoIBGE': codigo_ibge,
        'dataPlantio': data_plantio.strftime('%Y-%m-%d'),
        'cad': 100, 'expectativaProdutividade': 3000
    }

    try:
        r = requests.get(f"{BASE_AGRITEC_V2}/produtividade", headers=HEADERS, params=params)
        r.raise_for_status()
        dados = r.json().get("data", [])

        if not dados:
            return "[AUTONOMIA_GEMINI] Nenhum dado de produtividade encontrado."

        # Cria a tabela de dados
        tabela_str = tabulate(dados, headers="keys", tablefmt="github")

        return f"[DADOS DE API - PRODUTIVIDADE (Plantio: {data_plantio.strftime('%d/%m/%Y')})]\n{tabela_str}"

    except requests.exceptions.HTTPError as err:
        return f"‚ùå Erro na consulta de produtividade (Status {err.response.status_code})."
    except Exception as e:
        return f"‚ùå Erro inesperado ao consultar produtividade: {e}"

"""# API ClimAPI"""

def geocodificar_cidade(nome_cidade):
    """Converte nome da cidade -> (lat, lon) usando Nominatim gratuito."""
    q = f"{nome_cidade}, Brasil"
    params = {"q": q, "format": "json", "limit": 1}
    headers_geo = {"User-Agent": "Agritec-Chatbot/1.0"}

    try:
        r = requests.get(GEOCODE_URL, params=params, headers=headers_geo, timeout=10)
        r.raise_for_status()
        dados = r.json()
        if not dados: return None, None
        lat = float(dados[0]["lat"])
        lon = float(dados[0]["lon"])
        return lat, lon
    except Exception:
        return None, None

def listar_variaveis_clim():
    url = f"{BASE_CLIM}/ncep-gfs"
    try:
        r = requests.get(url, headers=HEADERS, timeout=12)
        r.raise_for_status()
        payload = r.json()
        return payload.get("data", []) if isinstance(payload, dict) else payload
    except Exception:
        return []

def pegar_datas_clim(nome_variavel):
    url = f"{BASE_CLIM}/ncep-gfs/{nome_variavel}"
    try:
        r = requests.get(url, headers=HEADERS, timeout=12)
        r.raise_for_status()
        payload = r.json()
        return payload.get("data", []) if isinstance(payload, dict) else payload
    except Exception:
        return []

def consultar_variavel_clim(nome_variavel, data_exec, lon, lat):
    url = f"{BASE_CLIM}/ncep-gfs/{nome_variavel}/{data_exec}/{lon}/{lat}"
    try:
        r = requests.get(url, headers=HEADERS, timeout=12)
        r.raise_for_status()
        return r.json()
    except Exception:
        return None

def consultar_clima_por_cidade(nome_cidade, max_variaveis=5, pausa=0.2):
    """Consulta clima. Retorna string formatada para o Gemini."""
    lat, lon = geocodificar_cidade(nome_cidade)
    if lat is None:
        return "[AUTONOMIA_GEMINI] N√£o consegui encontrar essa cidade no mapa para consulta clim√°tica."

    variaveis = listar_variaveis_clim()
    if not variaveis:
        return "‚ùå Nenhuma vari√°vel retornada pela ClimAPI. Verifique token."

    if max_variaveis:
        variaveis = variaveis[:max_variaveis]

    resultados = []
    for v in variaveis:
        nome = v.get("nome") if isinstance(v, dict) else v
        if not nome: continue

        datas = pegar_datas_clim(nome)
        if not datas: continue

        data_exec = datas[0] if isinstance(datas, list) and datas else datas
        if not data_exec: continue

        payload = consultar_variavel_clim(nome, data_exec, f"{lon:.6f}", f"{lat:.6f}")
        if payload:
            # Corre√ß√£o para lidar com payload sendo list ou dict
            if isinstance(payload, list) and payload:
                primeiro_item = payload[0]
                valor_resumo = str(primeiro_item.get('value', primeiro_item))[:50]
            elif isinstance(payload, dict):
                valor_resumo = str(payload.get('value', payload))[:50]
            else:
                valor_resumo = str(payload)[:50]

            resultados.append([nome, data_exec, valor_resumo])
        time.sleep(pausa)

    if not resultados:
        return "[AUTONOMIA_GEMINI] Nenhum dado retornado pela ClimAPI."

    header = ["Vari√°vel", "Data Execu√ß√£o", "Valor"]
    tabela_str = tabulate(resultados, headers=header, tablefmt="github")

    return f"[DADOS DE API - CLIMA (Cidade: {nome_cidade.title()}, Lat: {lat:.4f}, Lon: {lon:.4f})]\n{tabela_str}"

"""# API AGROFIT"""

# --- FUN√á√ïES AGROFIT (PRODUTO) ---
def consultar_agrofit(nome_produto):
    """Consulta produtos formulados (defensivos). Retorna string formatada para o Gemini."""
    url = f"{BASE_AGROFIT}/search/produtos-formulados"
    marca_comercial = nome_produto.split()[0]
    params = {'marca_comercial': marca_comercial}

    try:
        r = requests.get(url, headers=HEADERS, params=params, timeout=15)
        r.raise_for_status()
        json_data = r.json()

        dados = json_data.get("data", []) if isinstance(json_data, dict) and "data" in json_data else (json_data if isinstance(json_data, list) else [])

        if not dados:
            return f"[AUTONOMIA_GEMINI] Nenhum produto formulado encontrado no AGROFIT para a marca '{marca_comercial.title()}'."

        tabela = []
        for d in dados[:5]:
            tabela.append([
                d.get('marca_comercial', ['N/A'])[0],
                d.get('classe_categoria_agronomica', ['N/A'])[0],
                d.get('classificacao_toxicologica', 'N/A'),
                d.get('ingrediente_ativo', ['N/A'])[0]
            ])

        header = ["Marca Comercial", "Categoria Agron√¥mica", "Toxicologia", "Ingrediente Ativo"]
        tabela_str = tabulate(tabela, headers=header, tablefmt="github")

        return f"[DADOS DE API - AGROFIT (Produto: {nome_produto.title()})]\n{tabela_str}"

    except requests.exceptions.HTTPError as err:
        return f"‚ùå Erro HTTP AGROFIT (Produto): Status {getattr(err.response,'status_code','N/A')}. Verifique o token."
    except Exception as e:
        return f"‚ùå Erro ao consultar AGROFIT (Produto): {e}"

def consultar_praga(nome_praga):
    """Consulta pragas/doen√ßas e inicia a busca de defensivos se encontrar o nome cient√≠fico."""

    url_cientifico = f"{BASE_AGROFIT}/search/pragas-nomes-cientificos"
    params = {'q': nome_praga}
    nomes_cientificos = []

    try:
        r = requests.get(url_cientifico, headers=HEADERS, params=params, timeout=15)
        r.raise_for_status()
        json_data = r.json()
        dados = json_data.get("data", []) if isinstance(json_data, dict) else json_data
        nomes_cientificos = [d.get('nome') for d in dados if d.get('nome')]
    except:
        pass

    if len(nomes_cientificos) == 1:
        return consultar_defensivos_por_praga(nomes_cientificos[0])

    url_comum = f"{BASE_AGROFIT}/search/pragas-nomes-comuns"
    nomes_comuns = []
    try:
        r = requests.get(url_comum, headers=HEADERS, params=params, timeout=15)
        r.raise_for_status()
        json_data = r.json()
        dados = json_data.get("data", []) if isinstance(json_data, dict) else json_data
        nomes_comuns = [d.get('nome') for d in dados if d.get('nome')]
    except:
        pass

    if nomes_cientificos:
        nomes_str = ", ".join(nomes_cientificos)
        return f"[AUTONOMIA_GEMINI] M√∫ltiplos nomes cient√≠ficos encontrados para a busca '{nome_praga.title()}': {nomes_str}. Por favor, refa√ßa a pergunta especificando o nome cient√≠fico correto para a busca de defensivos."

    if nomes_comuns:
        nomes_str = ", ".join(nomes_comuns)
        return f"[AUTONOMIA_GEMINI] Termos comuns encontrados: {nomes_str}. Para prosseguir com a busca de defensivos, por favor, utilize o **nome cient√≠fico** da praga/doen√ßa."

    return "[AUTONOMIA_GEMINI] A consulta na base de dados AGROFIT n√£o retornou resultados espec√≠ficos para o termo buscado."

def consultar_defensivos_por_praga(nome_cientifico):
    """Busca defensivos. Retorna string formatada para o Gemini."""
    url = f"{BASE_AGROFIT}/search/produtos-formulados"
    params = {'praga_nome_cientifico': nome_cientifico, 'page': 1, 'page_size': 5}

    try:
        r = requests.get(url, headers=HEADERS, params=params, timeout=15)
        r.raise_for_status()
        json_data = r.json()
        dados = json_data.get("data", []) if isinstance(json_data, dict) else json_data

        if not dados:
            return f"[AUTONOMIA_GEMINI] Nenhum produto formulado encontrado para o controle de '{nome_cientifico}'."

        tabela = []
        for d in dados[:5]:
            culturas_uso = [ind.get('cultura') for ind in d.get('indicacao_uso', [])]
            tabela.append([
                d.get('marca_comercial', ['N/A'])[0],
                d.get('classe_categoria_agronomica', ['N/A'])[0],
                d.get('classificacao_toxicologica', 'N/A'),
                ", ".join(set(culturas_uso))
            ])

        header = ["Marca Comercial", "Categoria", "Toxicologia", "Culturas (Uso)"]
        tabela_str = tabulate(tabela, headers=header, tablefmt="github")

        return f"[DADOS DE API - AGROFIT (Defensivos para Praga '{nome_cientifico}')]\n{tabela_str}"

    except requests.exceptions.HTTPError as err:
        return f"‚ùå Erro HTTP AGROFIT (Defensivos por Praga): Status {getattr(err.response,'status_code','N/A')}."
    except Exception as e:
        return f"‚ùå Erro ao consultar AGROFIT: {e}"

"""# API RespondeAgro"""

# --- FUN√á√ÉO RESPONDEAGRO CORRIGIDA ---
def consultar_responde_agro(pergunta):
    """
    Consulta a API RespondeAgro. Retorna string formatada para o Gemini.
    """
    url = f"{BASE_RESPONDE_AGRO}/_search/template"
    payload = {
        "id": "query_all",
        "params": {
            "query_string": pergunta,
            "from": 0,
            "size": 1
        }
    }

    try:
        r = requests.post(url, headers=HEADERS, json=payload, timeout=15)
        r.raise_for_status()
        dados = r.json()

        if not dados or not dados.get('hits', {}).get('hits'):
            return "[AUTONOMIA_GEMINI] A consulta na base de dados RespondeAgro n√£o retornou resultados espec√≠ficos para a sua pergunta."

        melhor_hit = dados['hits']['hits'][0]['_source']
        resposta_texto_bruto = melhor_hit.get('answer') or melhor_hit.get('conteudo') or melhor_hit.get('resposta')

        if resposta_texto_bruto:
            resposta_texto_limpo = re.sub(r'<[^>]+>', '', resposta_texto_bruto)
            pergunta_encontrada = melhor_hit.get('question', 'N/A')
            fonte = f"(Fonte: {melhor_hit.get('livro', 'N/A')} - Ano: {melhor_hit.get('ano_publicacao', 'N/A')})"

            return f"[DADOS DE API - RESPONDEAGRO (Pergunta relacionada: {pergunta_encontrada})]\n{resposta_texto_limpo}\n{fonte}"
        else:
            return "[AUTONOMIA_GEMINI] A resposta foi encontrada, mas o campo de texto est√° vazio."

    except requests.exceptions.HTTPError as err:
        status = getattr(err.response,'status_code','N/A')
        return f"‚ùå Erro HTTP RespondeAgro: Falha de comunica√ß√£o (Status: {status})."
    except Exception as e:
        return f"‚ùå Erro ao consultar RespondeAgro: {e}"

"""# API SmartSolos (WORK IN PROGRESS - N√ÉO FUNCIONA)"""

# --- FUN√á√ïES SMARTSOLOS ADAPTADAS ---
# Payload de demonstra√ß√£o
PAYLOAD_MINIMALISTA = {
    "items": [
        {
            "ID_PONTO": "USER_P1",
            "DRENAGEM": 4,
            "HORIZONTES": [
                {
                    "SIMB_HORIZ": "A",
                    "LIMITE_SUP": 0,
                    "LIMITE_INF": 20,
                    "PH_AGUA": 6.5,
                    "CA_TROC": 5.0,
                    "MG_TROC": 1.0,
                    "AL_TROC": 0.0,
                    "ARGILA": 350,
                    "SILTE": 300,
                    "AREIA_GROS": 150,
                    "AREIA_FINA": 200,
                    "C_ORG": 20.0
                }
            ]
        }
    ]
}

def classificar_solo_exemplo():
    """Classifica√ß√£o de solo (demonstra√ß√£o). Retorna string formatada para o Gemini."""
    url = f"{BASE_SMARTSOLOS}/classification"
    payload_minimalista = {
        "items": [{"ID_PONTO": "USER_P1", "DRENAGEM": 4, "HORIZONTES": [{"SIMB_HORIZ": "A", "LIMITE_SUP": 0, "LIMITE_INF": 20, "PH_AGUA": 6.5, "ARGILA": 350}]}]
    }

    try:
        r = requests.post(url, headers=HEADERS, json=payload_minimalista, timeout=20)
        r.raise_for_status()
        dados = r.json()

        resultados = dados.get('items', [])
        if not resultados:
            return "[AUTONOMIA_GEMINI] Classifica√ß√£o retornou vazia ou em formato inesperado."

        c = resultados[0]
        tabela = [
            ["Ordem", c.get('ORDEM')],
            ["Subordem", c.get('SUBORDEM')],
            ["Grande Grupo", c.get('GDE_GRUPO')],
            ["Subgrupo", c.get('SUBGRUPO')]
        ]
        tabela_str = tabulate(tabela, headers=["N√≠vel", "Classifica√ß√£o"], tablefmt="github")

        return f"[DADOS DE API - SMARTSOLOS (Classifica√ß√£o Exemplo)]\n{tabela_str}"

    except requests.exceptions.HTTPError as err:
        status_code = getattr(err.response,'status_code','N/A')
        if status_code == 400: return f"‚ùå Erro 400: Requisi√ß√£o Inv√°lida."
        return f"‚ùå Erro na comunica√ß√£o SmartSolos: Status: {status_code}"
    except Exception as e:
        return f"‚ùå Erro ao consultar SmartSolos: {e}"

"""# PLN e L√≥gica do Chatbot

"""

def extrair_entidades(texto):
    texto_norm = texto.lower().replace("√©", "e").replace("√£", "a").replace("√≠", "i").replace("√ß", "c").replace("√¥", "o")
    cultura = next((c for c in CULTURAS if c in texto_norm), None)
    uf = next((val for key, val in ESTADOS.items() if re.search(r'\b' + key + r'\b', texto_norm)), None)
    data_plantio = re.search(r'(\d{1,2}/\d{1,2}/\d{2,4})', texto)
    cidade = None

    for nome_cidade in CIDADES_ORDENADAS:
        if re.search(r'\b' + re.escape(nome_cidade) + r'\b', texto_norm):
            cidade = nome_cidade
            break

    if not cidade:
        for ent in nlp(texto.lower()).ents:
            if ent.label_ in ("LOC", "GPE"):
                cidade = ent.text.lower()
                break

    return cultura, uf, cidade, data_plantio.group(1) if data_plantio else None

def classificar_intencao(texto):
    texto = texto.lower()
    if any(p in texto for p in ["plantar", "plantio", "√©poca", "quando semear", "melhor epoca", "zoneamento"]): return "zoneamento"
    if any(p in texto for p in ["cultivar", "variedade", "semente"]): return "cultivares"
    if any(p in texto for p in ["produtividade", "produ√ß√£o", "rendimento", "quanto produz"]): return "produtividade"
    if any(p in texto for p in ["defensivo", "agrofit", "produto", "inseticida", "fungicida", "herbicida"]): return "defensivo"
    if any(p in texto for p in ["praga", "doen√ßa", "fungo", "√°caro", "v√≠rus"]): return "praga"
    if any(p in texto for p in ["clima", "chuva", "temperatura", "previs√£o", "previsao"]): return "clima"
    if any(p in texto for p in ["solo", "an√°lise de solo", "smartsolos", "textura"]): return "solos"
    return "responde_agro" # Fallback para RespondeAgro


# --- FUN√á√ÉO DE RESPOSTA DO GEMINI (FINAL) ---
def responder_com_gemini(pergunta, intencao, dados_api, primeira_pergunta):
    """
    Usa o Gemini para processar os dados da API, resumir o conte√∫do, traduzir
    termos t√©cnicos (como c√≥digos de vari√°veis) e gerar uma resposta final concisa.
    """
    if GEMINI_MODEL is None:
        return "‚ö†Ô∏è O assistente de IA est√° indispon√≠vel. Verifique a configura√ß√£o do token do Gemini."

    saudacao = ""
    if primeira_pergunta:
        saudacao = "Ol√°! Como seu AgroAssist, especializado em dados da Embrapa, posso te ajudar com recomenda√ß√µes agr√≠colas. "

    # üí• L√ìGICA DE AUTONOMIA: Verifica se a API falhou em encontrar conte√∫do
    instrucao_autonomia = ""
    if "[AUTONOMIA_GEMINI]" in dados_api:
        instrucao_autonomia = "ATEN√á√ÉO: A base de dados da Embrapa n√£o retornou um conte√∫do espec√≠fico. Voc√™ deve IGNORAR a mensagem [AUTONOMIA_GEMINI] e usar seu CONHECIMENTO GERAL sobre o tema AGRO para formular uma resposta completa, concisa e profissional."

    # Remove a tag de autonomia para que ela n√£o polua o resumo.
    dados_api_para_prompt = dados_api.replace("[AUTONOMIA_GEMINI]", "").strip()

    prompt = f"""
Voc√™ √© o **AgroAssist**, um assistente agr√≠cola especializado em dados da Embrapa.
Seu objetivo √© gerar uma resposta final **concisa, clara e profissional** para o usu√°rio.

{instrucao_autonomia}

[Instru√ß√µes Essenciais para Resposta]
1. **TRADU√á√ÉO:** Para todas as tabelas ou dados brutos, **traduza os termos t√©cnicos** (ex: 'dpt2m' para 'temperatura do ponto de orvalho', 'cad' para 'Capacidade de √Ågua Dispon√≠vel') e apresente o resultado em linguagem natural.
2. **RESUMO:** Resuma o conte√∫do principal em 3-5 frases.
3. **SUPRESS√ÉO DE DADOS BRUTOS:** **N√ÉO REPITA O CONTE√öDO DA SE√á√ÉO [DADOS DE API] NA RESPOSTA FINAL** (incluindo tabelas formatadas em GitHub). Use-os apenas para gerar o resumo.
4. **FORMATO:** N√£o use '*' ou '#' para listas e textos normais. Use apenas **negrito** e **it√°lico**.

[Instru√ß√µes de Resposta]
- **Inten√ß√£o**: {intencao.upper()}
- **Pergunta Original**: {pergunta}
- **Dados da API (Processar e Apresentar)**:
{dados_api_para_prompt}

[Resposta Formatada]
"""
    try:
        response = GEMINI_MODEL.generate_content(prompt)
        texto_final = response.text.strip()

        if primeira_pergunta:
            texto_final = saudacao + texto_final

        texto_final = texto_final.replace('*', '').replace('_', '')

        return texto_final

    except Exception as e:
        print(f"‚ö†Ô∏è Erro na gera√ß√£o de resposta do Gemini: {e}")
        return f"‚ùå Erro ao processar a resposta. Dados brutos da API: {dados_api_para_prompt}"

# --- L√ìGICA PRINCIPAL DO CHATBOT (CORRIGIDA) ---
def chatbot():
    print("üåæ Bem-vindo ao Chatbot Agritec (v5.2 - Est√°vel e Integrado com Gemini)!")
    print("\nüìå Exemplos de perguntas:")
    print(" ¬† - Quando plantar milho em Piracicaba?")
    print(" ¬† - Cultivares de soja para o RS")
    print(" ¬† - Produtividade de soja para Porto Alegre em 01/01/2024")
    print(" ¬† - Clima em Curitiba")
    print(" ¬† - O que √© ferrugem asi√°tica da soja?")
    print(" ¬† - Qual o melhor fungicida Priori para soja?")
    print(" ¬† - Qual a praga Spodoptera?")
    print(" ¬† - O que √© um Agrometeorologista?") # Exemplo de pergunta para autonomia do Gemini

    if not ACCESS_TOKEN:
        print("\nüõë Falha na autentica√ß√£o Embrapa. Verifique seu token."); return
    if not carregar_dados_da_api():
        print("\nüõë Falha ao carregar dados iniciais."); return

    contador_perguntas = 0

    while True:
        pergunta = input("\n> Digite sua pergunta (ou 'sair'): ")
        if pergunta.lower() == "sair":
            print("üëã At√© logo!"); break

        contador_perguntas += 1
        intencao = classificar_intencao(pergunta)
        cultura, uf, cidade, data_plantio = extrair_entidades(pergunta)
        dados_api_brutos = None

        id_cultura_encontrada = next((cid for c, cid in CULTURAS.items() if c == cultura), None)

        data_plantio_obj = None
        if data_plantio:
            try:
                data_plantio_obj = datetime.strptime(data_plantio, '%d/%m/%Y').date()
                if data_plantio_obj > date.today():
                    print("‚ùì A data de plantio n√£o pode ser no futuro."); continue
            except ValueError:
                print("‚ùì Formato de data inv√°lido. Use DD/MM/AAAA."); continue


        # ==========================================================
        # 1. A√á√ïES AGRITEC (EXIGEM CULTURA E/OU GEOGRAFIA)
        # ==========================================================
        if intencao in ["zoneamento", "produtividade", "cultivares"]:

            # Valida√ß√µes de cultura (Sempre necess√°rias para Agritec)
            if not cultura:
                # SE FALTA CULTURA, CAI NO FALLBACK
                intencao = "responde_agro"
            elif not id_cultura_encontrada:
                # Se a cultura existe na pergunta, mas n√£o na base da API, emitimos erro
                dados_api_brutos = f"‚ùå A cultura '{cultura}' n√£o foi encontrada em nossa base de dados Agritec."

            # Valida√ß√µes Geogr√°ficas (Se cultura OK, mas falta localiza√ß√£o, muda a inten√ß√£o para fallback)
            if not dados_api_brutos:
                if intencao in ["zoneamento", "produtividade"]:
                    if not cidade:
                        # üí• CORRE√á√ÉO: For√ßa o fallback para o Gemini responder sobre a cultura de forma geral
                        intencao = "responde_agro"
                    else:
                        codigo_ibge = CIDADES_COM_DADOS.get(cidade)
                        if not codigo_ibge:
                            dados_api_brutos = f"‚ùå N√£o encontrei o c√≥digo IBGE para a cidade '{cidade.title()}'."
                        elif intencao == "zoneamento":
                            dados_api_brutos = consultar_zoneamento(id_cultura_encontrada, codigo_ibge, cidade)
                        else: # produtividade
                            dados_api_brutos = consultar_produtividade(id_cultura_encontrada, codigo_ibge, cidade, data_plantio_obj or date.today())

                elif intencao == "cultivares":
                    if not uf:
                        # üí• CORRE√á√ÉO: For√ßa o fallback para o Gemini responder sobre a cultura
                        intencao = "responde_agro"
                    else:
                        dados_api_brutos = consultar_cultivares(id_cultura_encontrada, uf)

        # ==========================================================
        # 2. A√á√ïES CLIMAPI
        # ==========================================================
        elif intencao == "clima":
            if not cidade:
                intencao = "responde_agro" # For√ßa fallback
            else:
                dados_api_brutos = consultar_clima_por_cidade(cidade)

        # ==========================================================
        # 3. A√á√ïES SMARTSOLOS (Demonstra√ß√£o de Classifica√ß√£o)
        # ==========================================================
        elif intencao == "solos":
            dados_api_brutos = classificar_solo_exemplo()

        # ==========================================================
        # 4. A√á√ïES AGROFIT (Defensivo/Praga)
        # ==========================================================
        elif intencao == "defensivo":
            termos_chave = ["defensivo", "agrofit", "produto", "inseticida", "fungicida", "herbicida", "consultar", "qual", "melhor"]
            nome_produto = None

            for termo in termos_chave:
                if termo in pergunta.lower():
                    nome_produto = pergunta.lower().split(termo, 1)[-1].strip()
                    break

            if not nome_produto or len(nome_produto.split()) < 1:
                nome_produto = " ".join(pergunta.split()[-3:]).lower()

            if nome_produto:
                nome_produto = re.sub(r'[^\w\s]', '', nome_produto).strip().lower()

            if not nome_produto:
                dados_api_brutos = "‚ùå N√£o foi poss√≠vel identificar o nome do produto para consulta. Tente ser mais espec√≠fico."
            else:
                dados_api_brutos = consultar_agrofit(nome_produto)

        elif intencao == "praga":
            termos_chave = ["praga", "doen√ßa", "fungo", "√°caro", "v√≠rus", "consultar", "qual"]
            nome_praga = None

            for termo in termos_chave:
                if termo in pergunta.lower():
                    nome_praga = pergunta.lower().split(termo, 1)[-1].strip()
                    break

            if not nome_praga:
                nome_praga = " ".join(pergunta.split()[-3:]).lower()

            if nome_praga:
                nome_praga = re.sub(r'[^\w\s]', '', nome_praga).strip().lower()

            if not nome_praga:
                dados_api_brutos = "‚ùå N√£o foi poss√≠vel identificar o nome da praga para consulta. Tente ser mais espec√≠fico."
            else:
                dados_api_brutos = consultar_praga(nome_praga)

        # ==========================================================
        # 5. FALLBACK (RESPONDEAGRO) - Padr√£o e acionado por valida√ß√£o
        # ==========================================================
        if intencao == "responde_agro":
            dados_api_brutos = consultar_responde_agro(pergunta)


        # ==========================================================
        # 6. PROCESSAMENTO DA RESPOSTA FINAL PELO GEMINI
        # ==========================================================
        if dados_api_brutos is not None:
            resposta_final = responder_com_gemini(
                pergunta,
                intencao,
                dados_api_brutos,
                contador_perguntas == 1 # Apenas a primeira pergunta recebe a sauda√ß√£o
            )
            print(f"\nü§ñ AgroAssist:\n{resposta_final}")
        else:
            print("\n‚ùå N√£o foi poss√≠vel gerar uma resposta. Erro interno: dados_api_brutos √© None.")

if __name__ == '__main__':
    chatbot()