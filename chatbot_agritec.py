# -*- coding: utf-8 -*-
"""Chatbot Agritec

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14J76fswkCY6-OoTq1UZ-UeY4HuPOxZez
"""

# -----------------------------------------------------------------------------
# CHATBOT AGRITEC - VERS√ÉO 4.0 (EST√ÅVEL E REVISADA)
#
# Principais Corre√ß√µes nesta vers√£o:
# - A fun√ß√£o de Aduba√ß√£o foi totalmente refeita para usar o endpoint correto
#   `/adubacao-correcao` com todos os par√¢metros obrigat√≥rios.
# - A mensagem de erro da fun√ß√£o Produtividade foi aprimorada.
# - Estabilidade geral e consist√™ncia com a documenta√ß√£o da API v2.
# -----------------------------------------------------------------------------

# ‚¨áÔ∏è Instalar depend√™ncias
!pip install -q requests spacy tabulate
!python -m spacy download pt_core_news_sm

# üì¶ Importar bibliotecas
import base64
import requests
import spacy
from tabulate import tabulate
from datetime import date, datetime
import re
import locale

try:
    locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
except locale.Error:
    print("Aviso: Locale 'pt_BR.UTF-8' n√£o encontrado.")

print("Carregando modelo de linguagem...")
nlp = spacy.load("pt_core_news_sm")

# --- CONFIGURA√á√ÉO E AUTENTICA√á√ÉO ---

def get_access_token(consumer_key, consumer_secret):
    """Gera o token de acesso para autentica√ß√£o na API."""
    credentials = f"{consumer_key}:{consumer_secret}"
    auth_header = base64.b64encode(credentials.encode()).decode()
    token_url = "https://api.cnptia.embrapa.br/token"
    try:
        response = requests.post(token_url, headers={"Authorization": f"Basic {auth_header}"}, data={"grant_type": "client_credentials"}, verify=True)
        response.raise_for_status()
        token_data = response.json()
        print("‚úÖ Token de acesso gerado com sucesso!")
        return token_data.get("access_token")
    except Exception as e:
        print(f"‚ùå Erro Cr√≠tico ao gerar token: {e}")
        return None

CONSUMER_KEY = "_V86sJJfvDNJogUZezKttWEqwp8a"
CONSUMER_SECRET = "gAjHAthFQFyFcK2pYTuNan2cIQoa"
ACCESS_TOKEN = get_access_token(CONSUMER_KEY, CONSUMER_SECRET)

HEADERS = {"Authorization": f"Bearer {ACCESS_TOKEN}", "Accept": "application/json"} if ACCESS_TOKEN else {}

# --- BANCO DE DADOS EM MEM√ìRIA ---
CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS = {}, {}, {}, []
UFS_BRASIL = ['AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN', 'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO']

def carregar_dados_da_api():
    """Carrega todos os dados iniciais da API."""
    global CULTURAS, ESTADOS, CIDADES_COM_DADOS, CIDADES_ORDENADAS
    try:
        r_cult = requests.get("https://api.cnptia.embrapa.br/agritec/v2/culturas", headers=HEADERS)
        r_cult.raise_for_status()
        for item in r_cult.json().get("data", []):
            CULTURAS[item['nome'].lower().replace('√£', 'a').replace('√ß', 'c')] = item['id']
        print("‚úÖ Dados de Culturas carregados.")

        print("‚è≥ Carregando UFs e Munic√≠pios...")
        for uf in UFS_BRASIL:
            ESTADOS[uf.lower()] = uf
            r_mun = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/municipios?uf={uf}", headers=HEADERS)
            if r_mun.ok:
                for mun in r_mun.json().get("data", []):
                    CIDADES_COM_DADOS[mun['nome'].lower()] = str(mun['codigoIBGE'])
        CIDADES_ORDENADAS = sorted(CIDADES_COM_DADOS.keys(), key=len, reverse=True)
        print("‚úÖ Dados de Estados e Cidades carregados.")
        return True
    except Exception as e:
        print(f"‚ùå Falha cr√≠tica ao carregar dados: {e}")
        return False

# --- PROCESSAMENTO DE LINGUAGEM NATURAL (NPL) ---
def extrair_entidades(texto):
    texto_norm = texto.lower().replace("√©", "e").replace("√£", "a").replace("√≠", "i").replace("√ß", "c").replace("√¥", "o")
    cultura = next((c for c in CULTURAS if c in texto_norm), None)
    uf = next((val for key, val in ESTADOS.items() if re.search(r'\b' + key + r'\b', texto_norm)), None)
    cidade = None
    for ent in nlp(texto.lower()).ents:
        if ent.label_ == "LOC" and ent.text.lower() in CIDADES_COM_DADOS:
            cidade = ent.text.lower()
            break
    if not cidade:
        for nome_cidade in CIDADES_ORDENADAS:
            if re.search(r'\b' + re.escape(nome_cidade) + r'\b', texto_norm):
                cidade = nome_cidade
                break
    return cultura, uf, cidade

def classificar_intencao(texto):
    texto = texto.lower()
    if any(p in texto for p in ["plantar", "plantio", "√©poca", "quando semear", "melhor epoca", "zoneamento"]): return "zoneamento"
    if any(p in texto for p in ["cultivar", "variedade", "semente"]): return "cultivares"
    if any(p in texto for p in ["adubacao", "adubar", "fertilizante", "nutrientes", "solo"]): return "adubacao"
    if any(p in texto for p in ["produtividade", "produ√ß√£o", "rendimento", "quanto produz"]): return "produtividade"
    return "desconhecido"

# --- FUN√á√ïES DE CONSULTA √Ä API (VERS√ÉO 4.0) ---

def consultar_zoneamento(id_cultura, codigo_ibge, cidade_nome):
    """Endpoint: /agritec/v2/zoneamento"""
    print(f"\nüîé Consultando Zoneamento para {cidade_nome.title()}...")
    params = {'idCultura': id_cultura, 'codigoIBGE': codigo_ibge, 'idSolo': 1}
    for risco in [20, 30, 40]:
        params['risco'] = risco
        try:
            r = requests.get("https://api.cnptia.embrapa.br/agritec/v2/zoneamento", headers=HEADERS, params=params)
            if r.status_code == 404: continue
            r.raise_for_status()
            dados = r.json().get("data", [])
            if dados:
                print(f"\n‚úÖ Per√≠odo recomendado de plantio ({risco}% de risco):")
                tabela = [[d.get('solo'), f"De {d.get('diaIni')}/{d.get('mesIni')} a {d.get('diaFim')}/{d.get('mesFim')}"] for d in dados]
                print(tabulate(tabela, headers=["Tipo de Solo", "Per√≠odo Recomendado"]))
                return
        except requests.exceptions.HTTPError as err:
            print(f"  - Erro na API para risco {risco}%: {err.response.status_code}")
    print("‚ùå Nenhuma recomenda√ß√£o de zoneamento encontrada.")

def consultar_cultivares(id_cultura, uf):
    """Endpoint: /agritec/v2/cultivares"""
    print(f"\nüîé Consultando Cultivares para a UF {uf}...")
    try:
        r = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])
        if not dados:
            print("‚ùå Nenhuma cultivar encontrada.")
            return
        print("\n‚úÖ Cultivares recomendadas:")
        print(tabulate([[d.get('cultivar'), d.get('obtentor'), d.get('ciclo')] for d in dados], headers=["Cultivar", "Obtentor", "Ciclo"]))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta: {err.response.text}")

def consultar_adubacao(id_cultura, uf):
    """Endpoint: /adubacao-correcao - CORRIGIDO"""
    print(f"\nüîé Consultando Aduba√ß√£o e Corre√ß√£o de Solo para a UF {uf}...")
    # CORRE√á√ÉO: Este endpoint √© complexo e exige uma an√°lise de solo de exemplo.
    params = {
        'idCultura': id_cultura, 'uf': uf, 'texturaSolo': 1, 'produtividadeEstimada': 3000,
        'sistemaPlantio': 1, 'fosforo': 5.0, 'potassio': 0.2, 'aluminio': 0.1,
        'calcio': 2.0, 'magnesio': 0.8, 'vAtual': 40, 'vDesejado': 60
    }
    url = "https://api.cnptia.embrapa.br/agritec/v2/adubacao-correcao"
    try:
        r = requests.get(url, headers=HEADERS, params=params)
        r.raise_for_status()
        dados = r.json().get("data", {})
        if not dados:
            print("‚ùå Nenhuma recomenda√ß√£o de aduba√ß√£o encontrada.")
            return
        print("\n‚úÖ Recomenda√ß√µes (baseado em an√°lise de solo gen√©rica):")
        if dados.get('calagem'): print("\n--- Calagem ---"); print(tabulate(dados['calagem'], headers="keys", tablefmt="pretty"))
        if dados.get('gessagem'): print("\n--- Gessagem ---"); print(tabulate(dados['gessagem'], headers="keys", tablefmt="pretty"))
        if dados.get('adubacaoNPK'): print("\n--- Aduba√ß√£o NPK ---"); print(tabulate(dados['adubacaoNPK'], headers="keys", tablefmt="pretty"))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta de aduba√ß√£o: {err.response.text}")

def get_uf_from_ibge(codigo_ibge):
    uf_code = str(codigo_ibge)[:2]
    uf_map = {'11': 'RO', '12': 'AC', '13': 'AM', '14': 'RR', '15': 'PA', '16': 'AP', '17': 'TO', '21': 'MA', '22': 'PI', '23': 'CE', '24': 'RN', '25': 'PB', '26': 'PE', '27': 'AL', '28': 'SE', '29': 'BA', '31': 'MG', '32': 'ES', '33': 'RJ', '35': 'SP', '41': 'PR', '42': 'SC', '43': 'RS', '50': 'MS', '51': 'MT', '52': 'GO', '53': 'DF'}
    return uf_map.get(uf_code)

def obter_primeiro_id_cultivar(id_cultura, codigo_ibge):
    uf = get_uf_from_ibge(codigo_ibge)
    if not uf: return None
    try:
        r = requests.get(f"https://api.cnptia.embrapa.br/agritec/v2/cultivares?idCultura={id_cultura}&uf={uf}", headers=HEADERS)
        r.raise_for_status()
        dados = r.json().get("data", [])
        return dados[0]['id'] if dados and 'id' in dados[0] else None
    except:
        return None

def consultar_produtividade(id_cultura, codigo_ibge, cidade_nome):
    """Endpoint: /agritec/v2/produtividade"""
    print(f"\nüîé Consultando Produtividade para {cidade_nome.title()}...")
    id_cultivar = obter_primeiro_id_cultivar(id_cultura, codigo_ibge)
    if not id_cultivar:
        # Mensagem de erro aprimorada
        uf = get_uf_from_ibge(codigo_ibge)
        print(f"‚ùå N√£o foi poss√≠vel estimar a produtividade. Motivo: a API n√£o retornou uma 'cultivar' de refer√™ncia para esta cultura na regi√£o de {uf}.")
        print(f"   Tente primeiro a consulta 'cultivares de {CULTURAS.get(id_cultura, 'cultura')} em {uf}' para verificar a disponibilidade de dados.")
        return
    params = {
        'idCultura': id_cultura, 'idCultivar': id_cultivar, 'codigoIBGE': codigo_ibge,
        'dataPlantio': date.today().strftime('%Y-%m-%d'),
        'cad': 100, 'expectativaProdutividade': 3000
    }
    try:
        r = requests.get("https://api.cnptia.embrapa.br/agritec/v2/produtividade", headers=HEADERS, params=params)
        r.raise_for_status()
        dados = r.json().get("data", [])
        if not dados:
            print("‚ùå Nenhum dado de produtividade encontrado.")
            return
        print("\n‚úÖ Produtividade esperada:")
        print(tabulate(dados, headers="keys", tablefmt="pretty"))
    except requests.exceptions.HTTPError as err:
        print(f"‚ùå Erro na consulta de produtividade: {err.response.text}")

# --- L√ìGICA PRINCIPAL DO CHATBOT ---
def chatbot():
    print("üåæ Bem-vindo ao Chatbot Agritec (v4.0 - Est√°vel)!")
    print("\nüìå Exemplos de perguntas:")
    print("   - Quando plantar milho em Piracicaba?")
    print("   - Cultivares de soja para o RS")
    print("   - Adubacao para arroz em MG")
    print("   - Produtividade de trigo em Caxias do Sul")

    if not ACCESS_TOKEN:
        print("\nüõë Falha na autentica√ß√£o."); return
    if not carregar_dados_da_api():
        print("\nüõë Falha ao carregar dados iniciais."); return

    while True:
        pergunta = input("\n> Digite sua pergunta (ou 'sair'): ")
        if pergunta.lower() == "sair":
            print("üëã At√© logo!"); break

        intencao = classificar_intencao(pergunta)
        cultura, uf, cidade = extrair_entidades(pergunta)

        if not cultura:
            print("‚ùì N√£o identifiquei a cultura (ex: soja, milho)."); continue
        id_cultura_encontrada = next((cid for c, cid in CULTURAS.items() if c == cultura), None)

        if intencao in ["zoneamento", "produtividade"]:
            if not cidade:
                print(f"‚ùì Para '{intencao}', preciso da cidade."); continue
            codigo_ibge = CIDADES_COM_DADOS.get(cidade)
            if intencao == "zoneamento":
                consultar_zoneamento(id_cultura_encontrada, codigo_ibge, cidade)
            else:
                consultar_produtividade(id_cultura_encontrada, codigo_ibge, cidade)
        elif intencao in ["cultivares", "adubacao"]:
            if not uf:
                print(f"‚ùì Para '{intencao}', preciso do estado (UF)."); continue
            if intencao == "cultivares":
                consultar_cultivares(id_cultura_encontrada, uf)
            else:
                consultar_adubacao(id_cultura_encontrada, uf)
        else:
            print("‚ùì Desculpe, n√£o entendi o que voc√™ precisa. Tente uma pergunta como nos exemplos."); continue

if __name__ == '__main__':
    chatbot()